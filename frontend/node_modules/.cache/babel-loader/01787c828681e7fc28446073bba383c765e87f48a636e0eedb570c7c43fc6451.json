{"ast":null,"code":"/**\r\n * WebSocket客户端管理器\r\n * 处理用户会话WebSocket连接，接收踢出通知等实时消息\r\n */\n\nclass WebSocketManager {\n  constructor() {\n    this.socket = null;\n    this.reconnectCount = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectInterval = 3000; // 3秒\n    this.heartbeatInterval = 30000; // 30秒心跳\n    this.heartbeatTimer = null;\n    this.isConnecting = false;\n    this.isManualDisconnect = false;\n\n    // 事件监听器\n    this.listeners = {\n      onConnected: [],\n      onDisconnected: [],\n      onKickedOut: [],\n      onForceLogout: [],\n      onMessage: [],\n      onError: []\n    };\n  }\n\n  /**\r\n   * 连接WebSocket\r\n   * @param {string} token - 用户认证token\r\n   */\n  connect(token) {\n    // 更严格的连接状态检查\n    if (this.isConnecting) {\n      console.log('WebSocket正在连接中，跳过重复连接请求');\n      return false;\n    }\n    if (this.socket) {\n      if (this.socket.readyState === WebSocket.OPEN) {\n        console.log('WebSocket已连接，跳过重复连接请求');\n        return false;\n      } else if (this.socket.readyState === WebSocket.CONNECTING) {\n        console.log('WebSocket正在连接中，跳过重复连接请求');\n        return false;\n      } else {\n        // 如果有旧连接但已关闭，先清理\n        console.log('清理旧的WebSocket连接，准备新连接');\n        this.socket = null;\n      }\n    }\n    if (!token) {\n      console.error('WebSocket连接失败：缺少认证token');\n      return false;\n    }\n    this.isConnecting = true;\n    this.isManualDisconnect = false;\n    console.log('开始建立新的WebSocket连接...');\n    try {\n      // 构建WebSocket URL - 使用Vue代理，避免与HMR冲突\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const host = window.location.host; // 使用当前页面的host，通过Vue代理\n      const wsUrl = `${protocol}//${host}/websocket/users/session/?token=${token}`;\n      console.log('正在连接WebSocket:', wsUrl);\n      this.socket = new WebSocket(wsUrl);\n      this.socket.onopen = event => {\n        console.log('WebSocket连接已建立');\n        this.isConnecting = false;\n        this.reconnectCount = 0;\n\n        // 启动心跳\n        this.startHeartbeat();\n\n        // 触发连接事件\n        this.emit('onConnected', event);\n      };\n      this.socket.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('收到WebSocket消息:', data);\n\n          // 根据消息类型处理\n          switch (data.type) {\n            case 'connection_established':\n              console.log('WebSocket连接确认:', data.message);\n              break;\n            case 'kicked_out':\n              // 修复消息类型处理，与后端发送的一致\n              console.warn('用户被踢出:', data.message);\n              this.emit('onKickedOut', data);\n              break;\n            case 'force_logout':\n              // 保持与后端发送的一致\n              console.warn('强制登出:', data.message);\n              this.emit('onForceLogout', data);\n              break;\n            case 'pong':\n              // 心跳响应\n              console.log('心跳响应正常');\n              break;\n            case 'user_status':\n              console.log('用户状态更新:', data);\n              break;\n            default:\n              console.log('未知消息类型:', data.type);\n              this.emit('onMessage', data);\n          }\n        } catch (error) {\n          console.error('解析WebSocket消息失败:', error);\n        }\n      };\n      this.socket.onclose = event => {\n        console.log('WebSocket连接已关闭', event.code, event.reason);\n        this.isConnecting = false;\n\n        // 停止心跳\n        this.stopHeartbeat();\n\n        // 触发断开连接事件\n        this.emit('onDisconnected', event);\n\n        // 如果不是手动断开，尝试重连\n        if (!this.isManualDisconnect && this.reconnectCount < this.maxReconnectAttempts) {\n          this.scheduleReconnect(token);\n        }\n      };\n      this.socket.onerror = error => {\n        console.error('WebSocket连接错误:', error);\n        this.isConnecting = false;\n\n        // 触发错误事件\n        this.emit('onError', error);\n      };\n    } catch (error) {\n      console.error('创建WebSocket连接失败:', error);\n      this.isConnecting = false;\n      this.emit('onError', error);\n      return false;\n    }\n    return true;\n  }\n\n  /**\r\n   * 断开WebSocket连接\r\n   */\n  disconnect() {\n    this.isManualDisconnect = true;\n    this.stopHeartbeat();\n    if (this.socket) {\n      if (this.socket.readyState === WebSocket.OPEN) {\n        this.socket.close(1000, '用户主动断开连接');\n      }\n      this.socket = null;\n    }\n    this.reconnectCount = 0;\n    console.log('WebSocket连接已手动断开');\n  }\n\n  /**\r\n   * 发送消息\r\n   * @param {Object} message - 要发送的消息对象\r\n   */\n  send(message) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(message));\n      return true;\n    } else {\n      console.warn('WebSocket未连接，无法发送消息');\n      return false;\n    }\n  }\n\n  /**\r\n   * 启动心跳检测\r\n   */\n  startHeartbeat() {\n    this.stopHeartbeat(); // 先停止已有的心跳\n\n    this.heartbeatTimer = setInterval(() => {\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n        this.send({\n          type: 'ping',\n          timestamp: Date.now()\n        });\n      }\n    }, this.heartbeatInterval);\n  }\n\n  /**\r\n   * 停止心跳检测\r\n   */\n  stopHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  /**\r\n   * 安排重连\r\n   * @param {string} token - 认证token\r\n   */\n  scheduleReconnect(token) {\n    this.reconnectCount++;\n    console.log(`准备第${this.reconnectCount}次重连...`);\n    setTimeout(() => {\n      if (!this.isManualDisconnect && this.reconnectCount <= this.maxReconnectAttempts) {\n        console.log(`正在进行第${this.reconnectCount}次重连`);\n        this.connect(token);\n      }\n    }, this.reconnectInterval * this.reconnectCount); // 递增延迟\n  }\n\n  /**\r\n   * 添加事件监听器\r\n   * @param {string} eventType - 事件类型\r\n   * @param {Function} callback - 回调函数\r\n   */\n  on(eventType, callback) {\n    if (this.listeners[eventType] && typeof callback === 'function') {\n      this.listeners[eventType].push(callback);\n    }\n  }\n\n  /**\r\n   * 移除事件监听器\r\n   * @param {string} eventType - 事件类型\r\n   * @param {Function} callback - 回调函数\r\n   */\n  off(eventType, callback) {\n    if (this.listeners[eventType]) {\n      const index = this.listeners[eventType].indexOf(callback);\n      if (index > -1) {\n        this.listeners[eventType].splice(index, 1);\n      }\n    }\n  }\n\n  /**\r\n   * 触发事件\r\n   * @param {string} eventType - 事件类型\r\n   * @param {*} data - 事件数据\r\n   */\n  emit(eventType, data) {\n    if (this.listeners[eventType]) {\n      this.listeners[eventType].forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`事件监听器执行错误 (${eventType}):`, error);\n        }\n      });\n    }\n  }\n\n  /**\r\n   * 获取连接状态\r\n   */\n  getStatus() {\n    if (!this.socket) return 'DISCONNECTED';\n    switch (this.socket.readyState) {\n      case WebSocket.CONNECTING:\n        return 'CONNECTING';\n      case WebSocket.OPEN:\n        return 'CONNECTED';\n      case WebSocket.CLOSING:\n        return 'CLOSING';\n      case WebSocket.CLOSED:\n        return 'CLOSED';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n\n  /**\r\n   * 检查是否已连接\r\n   */\n  isConnected() {\n    return this.socket && this.socket.readyState === WebSocket.OPEN;\n  }\n}\n\n// 创建全局WebSocket管理器实例\nconst websocketManager = new WebSocketManager();\nexport default websocketManager;","map":{"version":3,"names":["WebSocketManager","constructor","socket","reconnectCount","maxReconnectAttempts","reconnectInterval","heartbeatInterval","heartbeatTimer","isConnecting","isManualDisconnect","listeners","onConnected","onDisconnected","onKickedOut","onForceLogout","onMessage","onError","connect","token","console","log","readyState","WebSocket","OPEN","CONNECTING","error","protocol","window","location","host","wsUrl","onopen","event","startHeartbeat","emit","onmessage","data","JSON","parse","type","message","warn","onclose","code","reason","stopHeartbeat","scheduleReconnect","onerror","disconnect","close","send","stringify","setInterval","timestamp","Date","now","clearInterval","setTimeout","on","eventType","callback","push","off","index","indexOf","splice","forEach","getStatus","CLOSING","CLOSED","isConnected","websocketManager"],"sources":["E:/A_project/yuanchi/AIops/frontend/src/utils/websocketManager.js"],"sourcesContent":["/**\r\n * WebSocket客户端管理器\r\n * 处理用户会话WebSocket连接，接收踢出通知等实时消息\r\n */\r\n\r\nclass WebSocketManager {\r\n  constructor() {\r\n    this.socket = null;\r\n    this.reconnectCount = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.reconnectInterval = 3000; // 3秒\r\n    this.heartbeatInterval = 30000; // 30秒心跳\r\n    this.heartbeatTimer = null;\r\n    this.isConnecting = false;\r\n    this.isManualDisconnect = false;\r\n    \r\n    // 事件监听器\r\n    this.listeners = {\r\n      onConnected: [],\r\n      onDisconnected: [],\r\n      onKickedOut: [],\r\n      onForceLogout: [],\r\n      onMessage: [],\r\n      onError: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 连接WebSocket\r\n   * @param {string} token - 用户认证token\r\n   */\r\n  connect(token) {\r\n    // 更严格的连接状态检查\r\n    if (this.isConnecting) {\r\n      console.log('WebSocket正在连接中，跳过重复连接请求');\r\n      return false;\r\n    }\r\n    \r\n    if (this.socket) {\r\n      if (this.socket.readyState === WebSocket.OPEN) {\r\n        console.log('WebSocket已连接，跳过重复连接请求');\r\n        return false;\r\n      } else if (this.socket.readyState === WebSocket.CONNECTING) {\r\n        console.log('WebSocket正在连接中，跳过重复连接请求');\r\n        return false;\r\n      } else {\r\n        // 如果有旧连接但已关闭，先清理\r\n        console.log('清理旧的WebSocket连接，准备新连接');\r\n        this.socket = null;\r\n      }\r\n    }\r\n\r\n    if (!token) {\r\n      console.error('WebSocket连接失败：缺少认证token');\r\n      return false;\r\n    }\r\n\r\n    this.isConnecting = true;\r\n    this.isManualDisconnect = false;\r\n    \r\n    console.log('开始建立新的WebSocket连接...');\r\n\r\n    try {\r\n      // 构建WebSocket URL - 使用Vue代理，避免与HMR冲突\r\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n      const host = window.location.host; // 使用当前页面的host，通过Vue代理\r\n      const wsUrl = `${protocol}//${host}/websocket/users/session/?token=${token}`;\r\n\r\n      console.log('正在连接WebSocket:', wsUrl);\r\n\r\n      this.socket = new WebSocket(wsUrl);\r\n\r\n      this.socket.onopen = (event) => {\r\n        console.log('WebSocket连接已建立');\r\n        this.isConnecting = false;\r\n        this.reconnectCount = 0;\r\n        \r\n        // 启动心跳\r\n        this.startHeartbeat();\r\n        \r\n        // 触发连接事件\r\n        this.emit('onConnected', event);\r\n      };\r\n\r\n      this.socket.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          console.log('收到WebSocket消息:', data);\r\n\r\n          // 根据消息类型处理\r\n          switch (data.type) {\r\n            case 'connection_established':\r\n              console.log('WebSocket连接确认:', data.message);\r\n              break;\r\n              \r\n            case 'kicked_out':  // 修复消息类型处理，与后端发送的一致\r\n              console.warn('用户被踢出:', data.message);\r\n              this.emit('onKickedOut', data);\r\n              break;\r\n              \r\n            case 'force_logout':  // 保持与后端发送的一致\r\n              console.warn('强制登出:', data.message);\r\n              this.emit('onForceLogout', data);\r\n              break;\r\n              \r\n            case 'pong':\r\n              // 心跳响应\r\n              console.log('心跳响应正常');\r\n              break;\r\n              \r\n            case 'user_status':\r\n              console.log('用户状态更新:', data);\r\n              break;\r\n              \r\n            default:\r\n              console.log('未知消息类型:', data.type);\r\n              this.emit('onMessage', data);\r\n          }\r\n        } catch (error) {\r\n          console.error('解析WebSocket消息失败:', error);\r\n        }\r\n      };\r\n\r\n      this.socket.onclose = (event) => {\r\n        console.log('WebSocket连接已关闭', event.code, event.reason);\r\n        this.isConnecting = false;\r\n        \r\n        // 停止心跳\r\n        this.stopHeartbeat();\r\n        \r\n        // 触发断开连接事件\r\n        this.emit('onDisconnected', event);\r\n        \r\n        // 如果不是手动断开，尝试重连\r\n        if (!this.isManualDisconnect && this.reconnectCount < this.maxReconnectAttempts) {\r\n          this.scheduleReconnect(token);\r\n        }\r\n      };\r\n\r\n      this.socket.onerror = (error) => {\r\n        console.error('WebSocket连接错误:', error);\r\n        this.isConnecting = false;\r\n        \r\n        // 触发错误事件\r\n        this.emit('onError', error);\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('创建WebSocket连接失败:', error);\r\n      this.isConnecting = false;\r\n      this.emit('onError', error);\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 断开WebSocket连接\r\n   */\r\n  disconnect() {\r\n    this.isManualDisconnect = true;\r\n    this.stopHeartbeat();\r\n    \r\n    if (this.socket) {\r\n      if (this.socket.readyState === WebSocket.OPEN) {\r\n        this.socket.close(1000, '用户主动断开连接');\r\n      }\r\n      this.socket = null;\r\n    }\r\n    \r\n    this.reconnectCount = 0;\r\n    console.log('WebSocket连接已手动断开');\r\n  }\r\n\r\n  /**\r\n   * 发送消息\r\n   * @param {Object} message - 要发送的消息对象\r\n   */\r\n  send(message) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify(message));\r\n      return true;\r\n    } else {\r\n      console.warn('WebSocket未连接，无法发送消息');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 启动心跳检测\r\n   */\r\n  startHeartbeat() {\r\n    this.stopHeartbeat(); // 先停止已有的心跳\r\n    \r\n    this.heartbeatTimer = setInterval(() => {\r\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n        this.send({\r\n          type: 'ping',\r\n          timestamp: Date.now()\r\n        });\r\n      }\r\n    }, this.heartbeatInterval);\r\n  }\r\n\r\n  /**\r\n   * 停止心跳检测\r\n   */\r\n  stopHeartbeat() {\r\n    if (this.heartbeatTimer) {\r\n      clearInterval(this.heartbeatTimer);\r\n      this.heartbeatTimer = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 安排重连\r\n   * @param {string} token - 认证token\r\n   */\r\n  scheduleReconnect(token) {\r\n    this.reconnectCount++;\r\n    console.log(`准备第${this.reconnectCount}次重连...`);\r\n    \r\n    setTimeout(() => {\r\n      if (!this.isManualDisconnect && this.reconnectCount <= this.maxReconnectAttempts) {\r\n        console.log(`正在进行第${this.reconnectCount}次重连`);\r\n        this.connect(token);\r\n      }\r\n    }, this.reconnectInterval * this.reconnectCount); // 递增延迟\r\n  }\r\n\r\n  /**\r\n   * 添加事件监听器\r\n   * @param {string} eventType - 事件类型\r\n   * @param {Function} callback - 回调函数\r\n   */\r\n  on(eventType, callback) {\r\n    if (this.listeners[eventType] && typeof callback === 'function') {\r\n      this.listeners[eventType].push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 移除事件监听器\r\n   * @param {string} eventType - 事件类型\r\n   * @param {Function} callback - 回调函数\r\n   */\r\n  off(eventType, callback) {\r\n    if (this.listeners[eventType]) {\r\n      const index = this.listeners[eventType].indexOf(callback);\r\n      if (index > -1) {\r\n        this.listeners[eventType].splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 触发事件\r\n   * @param {string} eventType - 事件类型\r\n   * @param {*} data - 事件数据\r\n   */\r\n  emit(eventType, data) {\r\n    if (this.listeners[eventType]) {\r\n      this.listeners[eventType].forEach(callback => {\r\n        try {\r\n          callback(data);\r\n        } catch (error) {\r\n          console.error(`事件监听器执行错误 (${eventType}):`, error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取连接状态\r\n   */\r\n  getStatus() {\r\n    if (!this.socket) return 'DISCONNECTED';\r\n    \r\n    switch (this.socket.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return 'CONNECTING';\r\n      case WebSocket.OPEN:\r\n        return 'CONNECTED';\r\n      case WebSocket.CLOSING:\r\n        return 'CLOSING';\r\n      case WebSocket.CLOSED:\r\n        return 'CLOSED';\r\n      default:\r\n        return 'UNKNOWN';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 检查是否已连接\r\n   */\r\n  isConnected() {\r\n    return this.socket && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\n// 创建全局WebSocket管理器实例\r\nconst websocketManager = new WebSocketManager();\r\n\r\nexport default websocketManager;"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,MAAMA,gBAAgB,CAAC;EACrBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAC7B,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAAC,CAAC;IAC/B,IAAI,CAACC,iBAAiB,GAAG,KAAK,CAAC,CAAC;IAChC,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB,IAAI,CAACC,kBAAkB,GAAG,KAAK;;IAE/B;IACA,IAAI,CAACC,SAAS,GAAG;MACfC,WAAW,EAAE,EAAE;MACfC,cAAc,EAAE,EAAE;MAClBC,WAAW,EAAE,EAAE;MACfC,aAAa,EAAE,EAAE;MACjBC,SAAS,EAAE,EAAE;MACbC,OAAO,EAAE;IACX,CAAC;EACH;;EAEA;AACF;AACA;AACA;EACEC,OAAOA,CAACC,KAAK,EAAE;IACb;IACA,IAAI,IAAI,CAACV,YAAY,EAAE;MACrBW,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;MACtC,OAAO,KAAK;IACd;IAEA,IAAI,IAAI,CAAClB,MAAM,EAAE;MACf,IAAI,IAAI,CAACA,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;QAC7CJ,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;QACpC,OAAO,KAAK;MACd,CAAC,MAAM,IAAI,IAAI,CAAClB,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACE,UAAU,EAAE;QAC1DL,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;QACtC,OAAO,KAAK;MACd,CAAC,MAAM;QACL;QACAD,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;QACpC,IAAI,CAAClB,MAAM,GAAG,IAAI;MACpB;IACF;IAEA,IAAI,CAACgB,KAAK,EAAE;MACVC,OAAO,CAACM,KAAK,CAAC,yBAAyB,CAAC;MACxC,OAAO,KAAK;IACd;IAEA,IAAI,CAACjB,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAE/BU,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAC;IAEnC,IAAI;MACF;MACA,MAAMM,QAAQ,GAAGC,MAAM,CAACC,QAAQ,CAACF,QAAQ,KAAK,QAAQ,GAAG,MAAM,GAAG,KAAK;MACvE,MAAMG,IAAI,GAAGF,MAAM,CAACC,QAAQ,CAACC,IAAI,CAAC,CAAC;MACnC,MAAMC,KAAK,GAAG,GAAGJ,QAAQ,KAAKG,IAAI,mCAAmCX,KAAK,EAAE;MAE5EC,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEU,KAAK,CAAC;MAEpC,IAAI,CAAC5B,MAAM,GAAG,IAAIoB,SAAS,CAACQ,KAAK,CAAC;MAElC,IAAI,CAAC5B,MAAM,CAAC6B,MAAM,GAAIC,KAAK,IAAK;QAC9Bb,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;QAC7B,IAAI,CAACZ,YAAY,GAAG,KAAK;QACzB,IAAI,CAACL,cAAc,GAAG,CAAC;;QAEvB;QACA,IAAI,CAAC8B,cAAc,CAAC,CAAC;;QAErB;QACA,IAAI,CAACC,IAAI,CAAC,aAAa,EAAEF,KAAK,CAAC;MACjC,CAAC;MAED,IAAI,CAAC9B,MAAM,CAACiC,SAAS,GAAIH,KAAK,IAAK;QACjC,IAAI;UACF,MAAMI,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACN,KAAK,CAACI,IAAI,CAAC;UACnCjB,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEgB,IAAI,CAAC;;UAEnC;UACA,QAAQA,IAAI,CAACG,IAAI;YACf,KAAK,wBAAwB;cAC3BpB,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEgB,IAAI,CAACI,OAAO,CAAC;cAC3C;YAEF,KAAK,YAAY;cAAG;cAClBrB,OAAO,CAACsB,IAAI,CAAC,QAAQ,EAAEL,IAAI,CAACI,OAAO,CAAC;cACpC,IAAI,CAACN,IAAI,CAAC,aAAa,EAAEE,IAAI,CAAC;cAC9B;YAEF,KAAK,cAAc;cAAG;cACpBjB,OAAO,CAACsB,IAAI,CAAC,OAAO,EAAEL,IAAI,CAACI,OAAO,CAAC;cACnC,IAAI,CAACN,IAAI,CAAC,eAAe,EAAEE,IAAI,CAAC;cAChC;YAEF,KAAK,MAAM;cACT;cACAjB,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;cACrB;YAEF,KAAK,aAAa;cAChBD,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEgB,IAAI,CAAC;cAC5B;YAEF;cACEjB,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEgB,IAAI,CAACG,IAAI,CAAC;cACjC,IAAI,CAACL,IAAI,CAAC,WAAW,EAAEE,IAAI,CAAC;UAChC;QACF,CAAC,CAAC,OAAOX,KAAK,EAAE;UACdN,OAAO,CAACM,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;QAC1C;MACF,CAAC;MAED,IAAI,CAACvB,MAAM,CAACwC,OAAO,GAAIV,KAAK,IAAK;QAC/Bb,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEY,KAAK,CAACW,IAAI,EAAEX,KAAK,CAACY,MAAM,CAAC;QACvD,IAAI,CAACpC,YAAY,GAAG,KAAK;;QAEzB;QACA,IAAI,CAACqC,aAAa,CAAC,CAAC;;QAEpB;QACA,IAAI,CAACX,IAAI,CAAC,gBAAgB,EAAEF,KAAK,CAAC;;QAElC;QACA,IAAI,CAAC,IAAI,CAACvB,kBAAkB,IAAI,IAAI,CAACN,cAAc,GAAG,IAAI,CAACC,oBAAoB,EAAE;UAC/E,IAAI,CAAC0C,iBAAiB,CAAC5B,KAAK,CAAC;QAC/B;MACF,CAAC;MAED,IAAI,CAAChB,MAAM,CAAC6C,OAAO,GAAItB,KAAK,IAAK;QAC/BN,OAAO,CAACM,KAAK,CAAC,gBAAgB,EAAEA,KAAK,CAAC;QACtC,IAAI,CAACjB,YAAY,GAAG,KAAK;;QAEzB;QACA,IAAI,CAAC0B,IAAI,CAAC,SAAS,EAAET,KAAK,CAAC;MAC7B,CAAC;IAEH,CAAC,CAAC,OAAOA,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;MACxC,IAAI,CAACjB,YAAY,GAAG,KAAK;MACzB,IAAI,CAAC0B,IAAI,CAAC,SAAS,EAAET,KAAK,CAAC;MAC3B,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEuB,UAAUA,CAAA,EAAG;IACX,IAAI,CAACvC,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACoC,aAAa,CAAC,CAAC;IAEpB,IAAI,IAAI,CAAC3C,MAAM,EAAE;MACf,IAAI,IAAI,CAACA,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;QAC7C,IAAI,CAACrB,MAAM,CAAC+C,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC;MACrC;MACA,IAAI,CAAC/C,MAAM,GAAG,IAAI;IACpB;IAEA,IAAI,CAACC,cAAc,GAAG,CAAC;IACvBgB,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC;EACjC;;EAEA;AACF;AACA;AACA;EACE8B,IAAIA,CAACV,OAAO,EAAE;IACZ,IAAI,IAAI,CAACtC,MAAM,IAAI,IAAI,CAACA,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;MAC5D,IAAI,CAACrB,MAAM,CAACgD,IAAI,CAACb,IAAI,CAACc,SAAS,CAACX,OAAO,CAAC,CAAC;MACzC,OAAO,IAAI;IACb,CAAC,MAAM;MACLrB,OAAO,CAACsB,IAAI,CAAC,qBAAqB,CAAC;MACnC,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;EACER,cAAcA,CAAA,EAAG;IACf,IAAI,CAACY,aAAa,CAAC,CAAC,CAAC,CAAC;;IAEtB,IAAI,CAACtC,cAAc,GAAG6C,WAAW,CAAC,MAAM;MACtC,IAAI,IAAI,CAAClD,MAAM,IAAI,IAAI,CAACA,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;QAC5D,IAAI,CAAC2B,IAAI,CAAC;UACRX,IAAI,EAAE,MAAM;UACZc,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;QACtB,CAAC,CAAC;MACJ;IACF,CAAC,EAAE,IAAI,CAACjD,iBAAiB,CAAC;EAC5B;;EAEA;AACF;AACA;EACEuC,aAAaA,CAAA,EAAG;IACd,IAAI,IAAI,CAACtC,cAAc,EAAE;MACvBiD,aAAa,CAAC,IAAI,CAACjD,cAAc,CAAC;MAClC,IAAI,CAACA,cAAc,GAAG,IAAI;IAC5B;EACF;;EAEA;AACF;AACA;AACA;EACEuC,iBAAiBA,CAAC5B,KAAK,EAAE;IACvB,IAAI,CAACf,cAAc,EAAE;IACrBgB,OAAO,CAACC,GAAG,CAAC,MAAM,IAAI,CAACjB,cAAc,QAAQ,CAAC;IAE9CsD,UAAU,CAAC,MAAM;MACf,IAAI,CAAC,IAAI,CAAChD,kBAAkB,IAAI,IAAI,CAACN,cAAc,IAAI,IAAI,CAACC,oBAAoB,EAAE;QAChFe,OAAO,CAACC,GAAG,CAAC,QAAQ,IAAI,CAACjB,cAAc,KAAK,CAAC;QAC7C,IAAI,CAACc,OAAO,CAACC,KAAK,CAAC;MACrB;IACF,CAAC,EAAE,IAAI,CAACb,iBAAiB,GAAG,IAAI,CAACF,cAAc,CAAC,CAAC,CAAC;EACpD;;EAEA;AACF;AACA;AACA;AACA;EACEuD,EAAEA,CAACC,SAAS,EAAEC,QAAQ,EAAE;IACtB,IAAI,IAAI,CAAClD,SAAS,CAACiD,SAAS,CAAC,IAAI,OAAOC,QAAQ,KAAK,UAAU,EAAE;MAC/D,IAAI,CAAClD,SAAS,CAACiD,SAAS,CAAC,CAACE,IAAI,CAACD,QAAQ,CAAC;IAC1C;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEE,GAAGA,CAACH,SAAS,EAAEC,QAAQ,EAAE;IACvB,IAAI,IAAI,CAAClD,SAAS,CAACiD,SAAS,CAAC,EAAE;MAC7B,MAAMI,KAAK,GAAG,IAAI,CAACrD,SAAS,CAACiD,SAAS,CAAC,CAACK,OAAO,CAACJ,QAAQ,CAAC;MACzD,IAAIG,KAAK,GAAG,CAAC,CAAC,EAAE;QACd,IAAI,CAACrD,SAAS,CAACiD,SAAS,CAAC,CAACM,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;MAC5C;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE7B,IAAIA,CAACyB,SAAS,EAAEvB,IAAI,EAAE;IACpB,IAAI,IAAI,CAAC1B,SAAS,CAACiD,SAAS,CAAC,EAAE;MAC7B,IAAI,CAACjD,SAAS,CAACiD,SAAS,CAAC,CAACO,OAAO,CAACN,QAAQ,IAAI;QAC5C,IAAI;UACFA,QAAQ,CAACxB,IAAI,CAAC;QAChB,CAAC,CAAC,OAAOX,KAAK,EAAE;UACdN,OAAO,CAACM,KAAK,CAAC,cAAckC,SAAS,IAAI,EAAElC,KAAK,CAAC;QACnD;MACF,CAAC,CAAC;IACJ;EACF;;EAEA;AACF;AACA;EACE0C,SAASA,CAAA,EAAG;IACV,IAAI,CAAC,IAAI,CAACjE,MAAM,EAAE,OAAO,cAAc;IAEvC,QAAQ,IAAI,CAACA,MAAM,CAACmB,UAAU;MAC5B,KAAKC,SAAS,CAACE,UAAU;QACvB,OAAO,YAAY;MACrB,KAAKF,SAAS,CAACC,IAAI;QACjB,OAAO,WAAW;MACpB,KAAKD,SAAS,CAAC8C,OAAO;QACpB,OAAO,SAAS;MAClB,KAAK9C,SAAS,CAAC+C,MAAM;QACnB,OAAO,QAAQ;MACjB;QACE,OAAO,SAAS;IACpB;EACF;;EAEA;AACF;AACA;EACEC,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACpE,MAAM,IAAI,IAAI,CAACA,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACC,IAAI;EACjE;AACF;;AAEA;AACA,MAAMgD,gBAAgB,GAAG,IAAIvE,gBAAgB,CAAC,CAAC;AAE/C,eAAeuE,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}